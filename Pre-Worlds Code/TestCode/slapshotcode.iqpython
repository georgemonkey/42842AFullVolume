{"mode":"Text","textContent":"#region VEXcode Generated Robot Configuration\nfrom vex import *\nimport urandom\n\n# Brain should be defined by default\nbrain=Brain()\n\n# Robot configuration code\nbrain_inertial = Inertial()\nleft_motor = Motor(Ports.PORT6, False)\nright_motor = Motor(Ports.PORT12, False)\ngyro5 = Gyro(Ports.PORT5)\nflywheel_motor_a = Motor(Ports.PORT7, True)\nflywheel_motor_b = Motor(Ports.PORT4, False)\nflywheel = MotorGroup(flywheel_motor_a, flywheel_motor_b)\nbluearm = Motor(Ports.PORT9, False)\nseesaw = Motor(Ports.PORT10, True)\nt3 = Touchled(Ports.PORT3)\ndistance_9 = Distance(Ports.PORT2)\ndistance_11 = Sonar(Ports.PORT11)\ncolor_1 = ColorSensor(Ports.PORT1)\n#endregion VEXcode Generated Robot Configuration\n\n# ------------------------------------------\n# \n# \tProject:      VEXcode Project\n# \tAuthor:       VEX\n# \tCreated:\n# \tDescription:  VEXcode IQ Python Project\n# \n# ------------------------------------------\n\n# Library imports\n\n\n# Begin project code\nmyVariable = 0\nmessage1 = Event()\nFunction = Event()\n\ndef turning(target_angle, KP=2.1, KD = 6.485 , KI = 0.00, tol = 1, p = 3, wasting_time = True):\n    left_motor.spin(REVERSE)\n    right_motor.spin(REVERSE)\n    t3.set_color(Color.RED)\n    # Set the constants for the PID loop\n\n\n    error_sum = 0  # Initialize the error sum\n    last_error = 0  # Initialize the last errorx\n    error_offset = 0\n    prev_errors = [0,0,0]\n    while True:\n        \n        left_motor.set_stopping(HOLD)\n        right_motor.set_stopping(HOLD)\n        # Read the gyro5 angle\n        facing = gyro5.heading()\n\n        # Calculate the error`\n        error = target_angle - facing\n        error = error*-1\n        if error > 180:\n            error = error-360\n        if error <-180:\n            error = error+360\n\n        ##print(str(error))\n        # Calculate the proportional term\n        p_term = KP * error\n\n        # Calculate the integral term\n        error_sum += error\n        i_term = KI * error_sum\n        #if i_term > 50 or i_term < -50: \n        #    i_term = 0\n        # Calculate the derivative term\n        d_term = KD * (error - last_error)\n        last_error = error\n\n        # Calculate the PID output\n        if i_term >= 20:\n            i_term = 0\n        pid_output = p_term + i_term/10 + d_term\n        #brain.screen.#print(str(gyro5.heading()))\n\n        \n        \n        #print(str(pid_output) + \" p:\" + str(p_term) + \" i:\" + str(i_term/10) + \" d:\" +str(d_term) + \" e:\" + str(error))\n        #print()\n        pid_output = pid_output/p\n        # Set the motor speeds based on the PID output\n        left_motor.set_velocity(pid_output)\n        right_motor.set_velocity(pid_output)\n\n        # Check if the turn is complete\n        \n        #print(str(abs(error)))\n    \n        prev_errors[error_offset] = error\n        error_offset += 1\n        if error_offset == 3:\n            error_offset = 0\n        total_errors = 0\n        change_in_error = 0\n        change_in_error_large = False\n\n        for loop in range(len(prev_errors)):\n            ##print(str(i))\n            prev_error_number = prev_errors[loop]\n            total_errors += prev_error_number\n            if loop > 0:\n                change_in_error = prev_errors[loop] - prev_errors[loop-1]\n                #print(change_in_error)\n                if abs(float(change_in_error)) >= 0.07:\n                    change_in_error_large = True\n        if prev_errors[2] != 0:\n            if not change_in_error_large:\n                for x in range(5):\n                    pass\n                KP += 0.05\n        avg_error = total_errors/len(prev_errors)\n        if abs(error) < tol and abs(avg_error) < tol:\n            left_motor.stop()\n            right_motor.stop()\n            break\n\n        wait(10,MSEC)  # Wait for 20ms to allow the motors to move\n    t3.set_color(Color.GREEN)\n\n\ndef forwards(target_distance,speed = 50):\n    # Set target distance and speed\n    left_motor.set_velocity(speed, PERCENT)\n    right_motor.set_velocity(speed, PERCENT)\n    left_motor.set_position(0,DEGREES)\n    right_motor.set_position(0,DEGREES)\n    left_motor.set_stopping(COAST)\n    right_motor.set_stopping(COAST)\n    left_motor.spin(FORWARD)\n    right_motor.spin(REVERSE)\n    \n    # PID constawnts\n    kp = .1\n    ki = 0\n    kd = .5\n\n    # Initialize PID variables\n    error = 0\n    integral = 0\n    derivative = 0\n    last_error = 0\n    loop = 0\n    # Loop until target distance is reached\n    while (abs(left_motor.position(DEGREES)) + abs(right_motor.position(DEGREES))) / 2 < target_distance:\n        ##print(str((left_motor.position(DEGREES) + right_motor.position(DEGREES)) / 2))\n        # Calculate error\n        error = abs(left_motor.position(DEGREES)) - abs(right_motor.position(DEGREES))\n        ##print(str(left_motor.position(DEGREES)))\n        ##print(str(right_motor.position(DEGREES)))\n        # Calculate integral\n        integral += error\n        if ki * integral < -20:\n            integral = 0\n    \n        # Calculate derivative\n        derivative = error - last_error\n\n        # Calculate PID output\n        \n        output = kp * error + ki * integral + kd * derivative\n        ##print(str(error))\n        ##print(str(output) + \" p:\" + str(kp * error) + \" i:\" + str(ki * integral) + \" d:\" +str(kd * derivative))\n        ##print()\n        # Set motor speeds\n        \n        left_motor.set_velocity(-speed + output, PERCENT)\n        right_motor.set_velocity(speed + output, PERCENT)\n        ##print(str(-speed - output))\n        ##print(str(speed - output))\n    \n        # Update last error\n        last_error = error\n\n        # Wait a short time before looping again\n        wait(20,MSEC)\n\n    # Stop motors\n    left_motor.stop()\n    right_motor.stop()\n    left_motor.set_velocity(50, PERCENT)\n    right_motor.set_velocity(50, PERCENT)\n    wait(100,MSEC)\n    \ndef backwards(target_distance,speed = 50):\n    # Set target distance and speed   # in percent\n    left_motor.set_velocity(speed, PERCENT)\n    right_motor.set_velocity(speed, PERCENT)\n    left_motor.set_position(0,DEGREES)\n    right_motor.set_position(0,DEGREES)\n    left_motor.set_stopping(HOLD)\n    right_motor.set_stopping(HOLD)\n    left_motor.spin(FORWARD)\n    right_motor.spin(REVERSE)\n    \n    # PID constants\n    kp = .1\n    ki = 0\n    kd = .5\n\n    # Initialize PID variables\n    error = 0\n    integral = 0\n    derivative = 0\n    last_error = 0\n\n    # Loop until target distance is reached\n    while (abs(left_motor.position(DEGREES)) + abs(right_motor.position(DEGREES))) / 2 < target_distance:\n        ##print(str((left_motor.position(DEGREES) + right_motor.position(DEGREES)) / 2))\n        # Calculate error\n        error = abs(left_motor.position(DEGREES)) - abs(right_motor.position(DEGREES))\n        ##print(str(left_motor.position(DEGREES)))\n        ##print(str(right_motor.position(DEGREES)))\n        # Calculate integral\n        integral += error\n        if ki * integral < -20:\n            integral = 0\n    \n        # Calculate derivative\n        derivative = error - last_error\n\n        # Calculate PID output\n        output = kp * error + ki * integral + kd * derivative\n \n        ##print(str(error))\n        ##print(str(output) + \" p:\" + str(kp * error) + \" i:\" + str(ki * integral) + \" d:\" +str(kd * derivative))\n        ##print()\n        # Set motor speeds\n        \n        right_motor.set_velocity(-speed - output, PERCENT)\n        left_motor.set_velocity(speed - output, PERCENT)\n        ##print(str(-speed - output))\n        ##print(str(speed - output))\n\n        # Update last error\n        last_error = error\n\n        # Wait a short time before looping again\n        wait(20,MSEC)\n\n    # Stop motors\n    left_motor.stop()\n    right_motor.stop()\n    left_motor.set_velocity(50, PERCENT)\n    right_motor.set_velocity(50, PERCENT)\n    wait(100,MSEC)\n    \ndef forwarding(time,vel = 50,h = HOLD):\n    left_motor.set_stopping(h)\n    right_motor.set_stopping(h)\n    left_motor.set_velocity(vel,PERCENT)\n    right_motor.set_velocity(vel,PERCENT)\n    left_motor.spin(REVERSE)\n    right_motor.spin(FORWARD)\n    wait(time,MSEC)\n    left_motor.stop()\n    right_motor.stop()\n\ndef backwarding(time,vel = 50,h = HOLD):\n    left_motor.set_stopping(h)\n    right_motor.set_stopping(h)\n    left_motor.set_velocity(vel,PERCENT)\n    right_motor.set_velocity(vel,PERCENT)\n    left_motor.spin(FORWARD)\n    right_motor.spin(REVERSE)\n    wait(time,MSEC)\n    left_motor.stop()\n    right_motor.stop()\n\ndef dforward(dist, vel = 60):\n    left_motor.set_stopping(HOLD)\n    right_motor.set_stopping(HOLD)\n    left_motor.set_velocity(vel,PERCENT)\n    right_motor.set_velocity(vel,PERCENT)\n    left_motor.spin(REVERSE)\n    right_motor.spin(FORWARD)\n    rture = True\n    while True:\n        #print(str(distance_9.object_distance(MM)))\n        if distance_9.object_distance(MM) <= dist:\n            left_motor.stop()\n            right_motor.stop()\n            #print(\"hi\")\n            break\n            \ndef dbackward(dist, vel = 60):\n    left_motor.set_stopping(HOLD)\n    right_motor.set_stopping(HOLD)\n    left_motor.set_velocity(vel,PERCENT)\n    right_motor.set_velocity(vel,PERCENT)\n    left_motor.spin(FORWARD)\n    right_motor.spin(REVERSE)\n    rture = True\n    while True:\n        #print(str(distance_9.object_distance(MM)))\n        if distance_9.object_distance(MM) >= dist:\n            left_motor.stop()\n            right_motor.stop()\n            break\n    #print(str(distance_9.object_distance(MM)))\n\ndef shooting(flaps,vel=69.5,waittime = 750):\n    flywheel.set_velocity(vel,PERCENT)\n    flywheel.spin(FORWARD)\n    seesaw.set_velocity(100,PERCENT)\n    seesaw.set_max_torque(100,PERCENT)\n    for i in range(flaps):\n        seesaw.spin(FORWARD)\n        wait(waittime,MSEC)\n        seesaw.spin(REVERSE)\n        wait(400,MSEC)\n        ##print(str(i) +\" \" +str(seesaw.position(DEGREES)))\n\n    seesaw.stop()\n    #flywheel.stop()\n\ndef dropsetblue():\n    seesaw.spin_to_position(0,DEGREES)\n    bluearm.spin_to_position(-360,DEGREES)\n\ndef dropblue():\n    bluearm.spin_to_position(-470,DEGREES)\n    seesaw.spin(FORWARD)\n    wait(400,MSEC)\n    bluearm.spin_to_position(-360,DEGREES)\n    wait(300,MSEC)\n    seesaw.spin(REVERSE)\n    wait(400,MSEC)\n\n\ndef shuffle(num):\n    seesaw.set_stopping(HOLD)                                                               \n    seesaw.set_velocity(100,PERCENT)\n    seesaw.set_max_torque(100,PERCENT)\n    seesaw.spin_to_position(0,DEGREES)\n    for i in range(num):\n        for x in range(5):\n            print(str(i))\n        seesaw.spin(FORWARD)\n        while 50 < distance_11.distance(MM):\n            stalling = True\n        #print(\"hehe\")\n        seesaw.spin(REVERSE)\n        wait(500,MSEC)\n\ndef shuffle2():\n    seesaw.set_velocity(100,PERCENT)\n    seesaw.set_max_torque(100,PERCENT)\n    seesaw.set_stopping(HOLD)\n    seesaw.spin_to_position(0,DEGREES)\n    for i in range(3):\n        for x in range(5):\n            stalling = True\n        seesaw.spin(FORWARD)\n        while 50 < distance_11.distance(MM):\n            stalling = True\n        #print(\"hehe\")\n        seesaw.spin(REVERSE)\n        wait(500,MSEC)\n\n\n    seesaw.spin_to_position(100,DEGREES)\n\n\ndef shuffle1():\n    seesaw.set_velocity(100,PERCENT)\n    seesaw.set_max_torque(100,PERCENT)\n    seesaw.set_stopping(HOLD)\n    seesaw.spin_to_position(0,DEGREES)\n    for i in range(1):\n        for x in range(5):\n            stalling = True\n        seesaw.spin(FORWARD)\n        while 50 < distance_11.distance(MM):\n            stalling = True\n        #print(\"hehe\")\n        seesaw.spin(REVERSE)\n        wait(500,MSEC)\n\n\n\n\ndef shooting2():\n    flywheel.set_velocity(100,PERCENT)\n    flywheel.spin(FORWARD)\n    seesaw.set_velocity(100,PERCENT)\n    seesaw.set_max_torque(100,PERCENT)\n    wait(500,MSEC)\n    for i in range(2):\n        seesaw.spin(FORWARD)\n        wait(1000,MSEC)\n        seesaw.spin_to_position(0,DEGREES)\n   \ndef shooting1():\n    flywheel.set_velocity(100,PERCENT)\n    flywheel.spin(FORWARD)\n    seesaw.set_velocity(100,PERCENT)\n    seesaw.set_max_torque(100,PERCENT)\n    wait(500,MSEC)\n    for i in range(1):\n        seesaw.spin(FORWARD)\n        wait(1000,MSEC)\n        seesaw.spin_to_position(0,DEGREES)\n\ndef setblue():\n    bluearm.spin_to_position(0,DEGREES)\n    seesaw.spin_to_position(120,DEGREES)\n\n\ndef shufflem():\n    seesaw.spin(FORWARD)\n    while 50 < distance_11.distance(MM):\n        stalling = True\n    seesaw.spin(REVERSE)\n    wait(400,MSEC)\n    seesaw.spin_to_position(140,DEGREES)\n\n\n#CODE STARTS HERE\n\ndef coding(): \n    \n    gyro5.set_heading(0, DEGREES)\n    \n    wait(15,MSEC)\n    x = .9\n    wait(100,MSEC) \n    left_motor.set_stopping(BRAKE)\n    right_motor.set_stopping(BRAKE)\n    left_motor.set_velocity(75,PERCENT)\n    right_motor.set_velocity(75,PERCENT)\n    left_motor.spin(REVERSE)\n    right_motor.spin(FORWARD)\n    wait(1650,MSEC)\n    left_motor.stop()\n    right_motor.stop()\n    #forwarding(1650,75)\n    # left_motor.set_velocity(100,PERCENT)\n    # right_motor.set_velocity(100,PERCENT)\n    seesaw.set_velocity(100,PERCENT)\n    seesaw.set_max_torque(100,PERCENT)\n    for n in range(30):\n        stalling = True\n    left_motor.set_stopping(HOLD)\n    right_motor.set_stopping(HOLD)\n    for i in range(1):\n        seesaw.spin(FORWARD)\n        for n in range(30):\n            stalling = True\n        wait(750,MSEC)\n        seesaw.spin_to_position(0,DEGREES)\n    #shuffle(2)\n    #left_motor.set_stopping(COAST)\n    #right_motor.set_stopping(COAST)\n    \n    backwarding(750,75) \n      \n    wait(50,MSEC)\n   \n    ws2 = Thread( shuffle1 )\n    turning(133,1.2,0.75,0,0.5,2)\n    wait(100,MSEC)\n\n   \n    t3.set_color(Color.BLUE_GREEN)\n   \n    flywheel.stop()\n   \n    seesaw.set_stopping(HOLD)\n    flywheel.spin(REVERSE)\n    ws2 = Thread( shuffle2 )\n    backwarding(2075,40)\n    #dbackward(940,50)\n    wait(250,MSEC)\n    turning(85,2.1,1.5,0,1)\n    \n    wait(100,MSEC)\n    left_motor.set_stopping(BRAKE)\n    right_motor.set_stopping(BRAKE)\n    left_motor.set_velocity(30,PERCENT)\n    right_motor.set_velocity(30,PERCENT)\n    left_motor.spin(FORWARD)\n    right_motor.spin(REVERSE)\n    wait(1000,MSEC)\n    left_motor.stop()\n    right_motor.stop()\n    wait(4000,MSEC)\n    forwarding(650,60)\n    flywheel.stop()\n    turning(140,2.5,7)\n    backwarding(365,70)\n    turning(179,2.8,3,0,1)\n    forwarding(700,100)\n    left_motor.spin(REVERSE)\n    right_motor.spin(FORWARD)\n    seesaw.set_stopping(COAST)\n    bluearm.spin(REVERSE)\n    wait(800,MSEC)\n    seesaw.set_stopping(HOLD)\n    #gyro5.set_heading(180, DEGREES)\n    bluearm.spin_to_position(0,DEGREES)\n    bluearm.stop()\n    left_motor.stop()\n    right_motor.stop()      \n    flywheel.spin(FORWARD)\n    backwarding(700,50)\n    turning(238,2.2,2)\n    seesaw.spin_to_position(0,DEGREES)\n    ws2 = Thread(shufflem)\n    backwarding(1200,80)\n    turning(180,2.5,5.5,0,5)\n    backwarding(500,75)\n    seesaw.spin_to_position(0,DEGREES)\n    wait(500,MSEC)\n    shooting(3,70,800)\n    dropblue()\n    shooting(2,100,600)\n    shooting(1,100,1000)\n    \n    forwarding(200)\n    ws2 = Thread(setblue)\n    turning(90,2.1,6,0,1) \n    dforward(460,40)\n    turning(180.5,2.1,6.45,0,1)  \n    forwarding(1500,75) \n    seesaw.set_stopping(COAST)\n    left_motor.spin(REVERSE)\n    right_motor.spin(FORWARD)\n    bluearm.spin(REVERSE)\n    wait(800,MSEC)\n    seesaw.set_stopping(HOLD)\n    #gyro5.set_heading(180, DEGREES)\n    bluearm.spin_to_position(0,DEGREES)\n    bluearm.stop()\n    left_motor.stop()\n    right_motor.stop()\n    backwarding(675)\n    flywheel.set_velocity(100,PERCENT)\n    flywheel.spin(REVERSE)\n    turning(230,2.5)\n    forwarding(400)\n    turning(265,2.5)\n    left_motor.set_stopping(BRAKE)\n    right_motor.set_stopping(BRAKE)\n    left_motor.set_velocity(30,PERCENT)\n    right_motor.set_velocity(30,PERCENT)\n    left_motor.spin(FORWARD)\n    right_motor.spin(REVERSE)\n    wait(1100,MSEC)\n    left_motor.stop()\n    right_motor.stop()\n    wait(4000,MSEC)\n    forwarding(650,60)\n    flywheel.stop()\n    right_motor.spin(FORWARD)\n    while 182.5 < gyro5.heading():\n        print(str(gyro5.heading()))\n        stalling = True\n    right_motor.stop()\n    flywheel.spin(FORWARD)\n    #turning(180)\n    wait(250,MSEC)\n    wsd2 = Thread(dropsetblue)\n    wsd2 = Thread(shooting1)\n    backwarding(2000,100)\n    #shooting(2,75,800)\n    #wait(500,MSEC)\n    dropblue()\n    shooting(1,75,800)\n    shooting(1,75,1000)\n\n\n   \n    \n        \n    \n    forwarding(250)\n    turning(265,2.1,6.485,0,2)\n    backwarding(1000,80)\n    bluearm.set_velocity(75,PERCENT)\n    ws2 = Thread(bluearm.spin(FORWARD))\n    turning(180,4,5.5,0,1,5)\n    \n    \n\n\n   \n\n    \"\"\"\n\n\n    \"\"\"\n\n\n#activation\nwait(15,MSEC)\nseesaw.set_max_torque(100,PERCENT)\nseesaw.set_velocity(100,PERCENT)\nseesaw.set_stopping(HOLD)\nbluearm.set_max_torque(100,PERCENT)\nbluearm.set_velocity(100,PERCENT)   \nseesaw.spin_to_position(0,DEGREES)\nflywheel.set_velocity(100,PERCENT)\ngyro5.calibrate(GyroCalibrationType.NORMAL)\nt3.set_color(Color.BLUE_GREEN)\nseesaw.spin_to_position(0,DEGREES)\n\n\nt3.pressed(coding)\n","textLanguage":"python","rconfig":[{"port":[6],"name":"left_motor","customName":true,"deviceType":"Motor","deviceClass":"motor","setting":{"reversed":"false","fwd":"forward","rev":"reverse"},"triportSourcePort":22},{"port":[12],"name":"right_motor","customName":true,"deviceType":"Motor","deviceClass":"motor","setting":{"reversed":"false","fwd":"forward","rev":"reverse"},"triportSourcePort":22},{"port":[5],"name":"gyro5","customName":true,"deviceType":"Gyro","deviceClass":"gyro","setting":{},"triportSourcePort":22},{"port":[7,4],"name":"flywheel","customName":true,"deviceType":"MotorGroup","deviceClass":"motor_group","setting":{"fwd":"forward","rev":"reverse","motor_a_reversed":"true","motor_b_reversed":"false"},"triportSourcePort":22},{"port":[9],"name":"bluearm","customName":true,"deviceType":"Motor","deviceClass":"motor","setting":{"reversed":"false","fwd":"forward","rev":"reverse"},"triportSourcePort":22},{"port":[10],"name":"seesaw","customName":true,"deviceType":"Motor","deviceClass":"motor","setting":{"reversed":"true","fwd":"forward","rev":"reverse"},"triportSourcePort":22},{"port":[3],"name":"t3","customName":true,"deviceType":"TouchLED","deviceClass":"touchled","setting":{},"triportSourcePort":22},{"port":[2],"name":"distance_9","customName":true,"deviceType":"Distance","deviceClass":"distance","setting":{},"triportSourcePort":22},{"port":[11],"name":"distance_11","customName":false,"deviceType":"Distance","deviceClass":"sonar","setting":{},"triportSourcePort":22},{"port":[1],"name":"color_1","customName":false,"deviceType":"Color","deviceClass":"colorsensor","setting":{},"triportSourcePort":22}],"slot":2,"platform":"IQ","sdkVersion":"20220726.10.00.00","appVersion":"2.4.5","minVersion":"2.4.0","fileFormat":"1.2.0","icon":"","targetBrainGen":"Second","target":"Physical"}