{"mode":"Text","textContent":"#region VEXcode Generated Robot Configuration\nfrom vex import *\nimport urandom\n\n# Brain should be defined by default\nbrain=Brain()\n\n# Robot configuration code\nbrain_inertial = Inertial()\nleft_drive_smart = Motor(Ports.PORT7, 0.5, True)\nright_drive_smart = Motor(Ports.PORT12, 0.5, False)\ndrivetrain_gyro = Gyro(Ports.PORT3)\ndrivetrain = SmartDrive(left_drive_smart, right_drive_smart, drivetrain_gyro, 200)\nintake_motor_a = Motor(Ports.PORT1, True)\nintake_motor_b = Motor(Ports.PORT4, False)\nintake = MotorGroup(intake_motor_a, intake_motor_b)\nlift_motor_a = Motor(Ports.PORT2, False)\nlift_motor_b = Motor(Ports.PORT5, True)\nlift = MotorGroup(lift_motor_a, lift_motor_b)\ncontroller = Controller()\n\n\ndef calibrate_drivetrain():\n    # Calibrate the Drivetrain Gyro\n    sleep(200, MSEC)\n    brain.screen.print(\"Calibrating\")\n    brain.screen.next_row()\n    brain.screen.print(\"Gyro\")\n    drivetrain_gyro.calibrate(GyroCalibrationType.NORMAL)\n    while drivetrain_gyro.is_calibrating():\n        sleep(25, MSEC)\n    brain.screen.clear_screen()\n    brain.screen.set_cursor(1, 1)\n\n\n\n# define variables used for controlling motors based on controller inputs\ne_buttons_control_motors_stopped = True\n\n# define a task that will handle monitoring inputs from controller\ndef rc_auto_loop_function_controller():\n    global e_buttons_control_motors_stopped, remote_control_code_enabled\n    # process the controller input every 20 milliseconds\n    # update the motors based on the input values\n    while True:\n        if remote_control_code_enabled:\n            # check the buttonEUp/buttonEDown status\n            # to control lift\n            if controller.buttonEUp.pressing():\n                lift.spin(FORWARD)\n                e_buttons_control_motors_stopped = False\n            elif controller.buttonEDown.pressing():\n                lift.spin(REVERSE)\n                e_buttons_control_motors_stopped = False\n            elif not e_buttons_control_motors_stopped:\n                lift.stop()\n                # set the toggle so that we don't constantly tell the motor to stop when\n                # the buttons are released\n                e_buttons_control_motors_stopped = True\n        # wait before repeating the process\n        wait(20, MSEC)\n\n# define variable for remote controller enable/disable\nremote_control_code_enabled = True\n\nrc_auto_loop_thread_controller = Thread(rc_auto_loop_function_controller)\n#endregion VEXcode Generated Robot Configuration\n\nfrom vex import *\nimport urandom\n\n\n\nbrain=Brain()\n\n# Robot configuration code\nbrain_inertial = Inertial()\nleft_motor = Motor(Ports.PORT7, False)\nright_motor = Motor(Ports.PORT12, False)\ngyro5 = Gyro(Ports.PORT3)\n\n\ndef turning(target_angle, KP=3.3, KD = 6.3 , KI = 0.00, tol = 1, p = 3, wasting_time = True):\n    left_motor.spin(REVERSE)\n    right_motor.spin(REVERSE)\n   \n    \n\n\n    error_sum = 0  \n    last_error = 0  \n    error_offset = 0\n    prev_errors = [0,0,0]\n    while True:\n        \n        left_motor.set_stopping(HOLD)\n        right_motor.set_stopping(HOLD)\n        \n        facing = gyro5.heading()\n\n        \n        error = target_angle - facing\n        error = error*-1\n        if error > 180:\n            error = error-360\n        if error <-180:\n            error = error+360\n\n     \n        p_term = KP * error\n\n       \n        error_sum += error\n        i_term = KI * error_sum\n        \n        d_term = KD * (error - last_error)\n        last_error = error\n\n        i_term = 0\n        pid_output = p_term + i_term/10 + d_term\n        print(str(gyro5.heading()))\n        pid_output = pid_output/p\n       \n        left_motor.set_velocity(pid_output)\n        right_motor.set_velocity(pid_output)\n\n        \n        prev_errors[error_offset] = error\n        error_offset += 1\n        if error_offset == 3:\n            error_offset = 0\n        total_errors = 0\n        change_in_error = 0\n        change_in_error_large = False\n        \n        for loop in range(len(prev_errors)):\n            \n            prev_error_number = prev_errors[loop]\n            total_errors += prev_error_number\n            if loop > 0:\n                change_in_error = prev_errors[loop] - prev_errors[loop-1]\n             \n                if abs(float(change_in_error)) >= 0.07:\n                    change_in_error_large = True\n        if prev_errors[2] != 0:\n            if not change_in_error_large:\n                for x in range(5):\n                    pass\n                KP += 0.1\n        avg_error = total_errors/len(prev_errors)\n        \n        if abs(error) < tol and abs(avg_error) < tol:\n            left_motor.stop()\n            right_motor.stop()\n            break\n\n        wait(10,MSEC)  \ndef forward(dist,lv,rv):\n   left_motor.set_velocity(lv,PERCENT)\n   right_motor.set_velocity(rv,PERCENT)\n   right_motor.spin(REVERSE)\n   left_motor.spin(FORWARD)\n   wait(dist,SECONDS)   \n   left_motor.stop() \n   right_motor.stop()\n   left_motor.set_stopping(HOLD)\n   right_motor.set_stopping(HOLD)\n   \n\ndef reverse(rdist):\n   left_motor.set_velocity(100,PERCENT)\n   right_motor.set_velocity(100,PERCENT)\n   left_motor.spin(REVERSE)\n   right_motor.spin(FORWARD)\n   wait(rdist,SECONDS)   \n   left_motor.stop() \n   right_motor.stop()     \n   \nbrain_inertial.set_heading(0, DEGREES)\nintake.set_velocity(100, PERCENT)\nlift.set_velocity(50,PERCENT)\nintake.set_max_torque(100, PERCENT)\n\n\n\nintake.spin(REVERSE)\nforward(0.2,100,100)\nturning(-45)\nforward(0.7,75,75)\nturning(0)\nforward(1.0,75,75)\nreverse(1.0)\nturning(-50)\nforward(1.2,50,50)\nwait(2,SECONDS)\nturning(0)\n\n\n\n\"\"\"\nforward(0.25,100,100)\nwait(0.5,SECONDS)\nforward(0.5,100,100)\nwait(0.5,SECONDS)\nforward(0.5,75,75)\nwait(0.5,SECONDS)\nforward(2.2,100,100)\nturning(-50)\nforward(0.6,100,83)\nwait(3,SECONDS)\nforward(0.5,100,83)\nwait(3,SECONDS)\nforward(1.7,50,41.5)\nwait(4,SECONDS)\nforward(0.5,100,83)\nwait(3,SECONDS)\nforward(0.7,100,83)\nwait(4,SECONDS)\nintake.stop()\nlift.spin_for(FORWARD,730, DEGREES)\n\"\"\"\n#purple\n#lift.spin_for(FORWARD, 180, DEGREES)\n#green\n#lift.spin_for(FORWARD,720, DEGREES)\n#standarddrive\n#forward(1,100,83)\n#precisondrive\n#forward(1,50,41.5)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","textLanguage":"python","rconfig":[{"port":[7,12,3],"name":"drivetrain","customName":false,"deviceType":"Drivetrain","deviceClass":"smartdrive","setting":{"type":"2-motor","wheelSize":"200mm","gearRatio":"1:2","direction":"rev","gyroType":"smart","width":"173","unit":"mm","wheelbase":"76","wheelbaseUnit":"mm","xOffset":"0","yOffset":"0","thetaOffset":"0"},"triportSourcePort":22},{"port":[1,4],"name":"intake","customName":true,"deviceType":"MotorGroup","deviceClass":"motor_group","setting":{"fwd":"forward","rev":"reverse","motor_a_reversed":"true","motor_b_reversed":"false"},"triportSourcePort":22},{"port":[2,5],"name":"lift","customName":true,"deviceType":"MotorGroup","deviceClass":"motor_group","setting":{"fwd":"forward","rev":"reverse","motor_a_reversed":"false","motor_b_reversed":"true"},"triportSourcePort":22},{"port":[],"name":"controller","customName":false,"deviceType":"Controller","deviceClass":"controller","setting":{"left":"","leftDir":"false","right":"","rightDir":"false","e":"lift","eDir":"false","f":"","fDir":"false","l3r3":"","l3r3Dir":"false","drive":"none"},"triportSourcePort":22}],"slot":0,"platform":"IQ","sdkVersion":"20220726.10.00.00","appVersion":"2.4.5","minVersion":"2.4.0","fileFormat":"1.2.0","icon":"","targetBrainGen":"Second","target":"Physical"}