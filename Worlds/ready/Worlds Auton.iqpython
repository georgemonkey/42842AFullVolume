{"mode":"Text","textContent":"#region VEXcode Generated Robot Configuration\nfrom vex import *\nimport urandom\n\n# Brain should be defined by default\nbrain=Brain()\n\n# Robot configuration code\nbrain_inertial = Inertial()\nleft_motor = Motor(Ports.PORT6, False)\nright_motor = Motor(Ports.PORT12, False)\nptoleft_motor_motor_a = Motor(Ports.PORT4, False)\nptoleft_motor_motor_b = Motor(Ports.PORT5, False)\nptoleft_motor = MotorGroup(ptoleft_motor_motor_a, ptoleft_motor_motor_b)\nptoright_motor_motor_a = Motor(Ports.PORT10, False)\nptoright_motor_motor_b = Motor(Ports.PORT11, False)\nptoright_motor = MotorGroup(ptoright_motor_motor_a, ptoright_motor_motor_b)\nleftsoildnoid = Pneumatic(Ports.PORT3)\nrightsoildnoid = Pneumatic(Ports.PORT9)\ncontroller = Controller()\ngyro7 = Gyro(Ports.PORT7)\n\n\n\n# Make random actually random\ndef setRandomSeedUsingAccel():\n    wait(100, MSEC)\n    xaxis = brain_inertial.acceleration(XAXIS) * 1000\n    yaxis = brain_inertial.acceleration(YAXIS) * 1000\n    zaxis = brain_inertial.acceleration(ZAXIS) * 1000\n    urandom.seed(int(xaxis + yaxis + zaxis))\n    \n# Set random seed \nsetRandomSeedUsingAccel()\n\n#endregion VEXcode Generated Robot Configuration\n# ------------------------------------------\n# \n# \tProject:      VEXcode Project\n# \tAuthor:       VEX\n# \tCreated:\n# \tDescription:  VEXcode IQ Python Project\n# \n# ------------------------------------------\n\n'''\nleft solenoid cylinder 1: left purple release\nleft solenoid cylinder 2: lift pto\nright solenoid cylinder 1: full park pto (flipped)\nright solenoid cylinder 2: right purple release\n'''\n\n# library imports\nfrom vex import *\n\n# curving\ndef curve(target, ratio, kp, ki, kd, tol=1.5):\n    left_motor.spin(REVERSE)\n    right_motor.spin(FORWARD)\n    #t4.set_color(Color.RED)\n    integral, prev = 0, 0\n    while True:\n        facing = gyro7.heading()\n        error = target - facing\n        if error > 180:\n            error -= 360\n        if error < -180:\n            error += 360\n        integral += error\n        if error == 0 or abs(error) > 40:\n            integral = 0\n        derivative = error - prev\n        prev = error\n        speed = kp*error + ki*integral + kd*derivative\n        if error > 0:\n            right_motor.set_velocity(speed,PERCENT)\n            left_motor.set_velocity((ratio*speed*-1),PERCENT)\n        if error < 0:\n            left_motor.set_velocity(speed,PERCENT)\n            right_motor.set_velocity(ratio*speed*-1,PERCENT)\n        if abs(error) < tol:\n            left_motor.stop()\n            right_motor.stop()\n            break\n        wait(10,MSEC)\n\n    #t4.set_color(Color.GREEN)\n\n# turning\ndef turning(target_angle, tol=1.5, Kp=1.2, Ki=0, Kd=0):\n    left_motor.spin(REVERSE)\n    right_motor.spin(REVERSE)\n  \n    #t4.set_color(Color.RED)\n    integral = 0\n    prev_error = 0\n\n    while True:\n        left_motor.set_stopping(HOLD)\n        right_motor.set_stopping(HOLD)\n        #finding error\n        facing = gyro7.heading()\n        \n        error = target_angle-facing\n        #print.error\n        #integral stuff\n        integral += error\n        if error > 180:\n            error = error-360\n        if error < -180:\n            error = error+360\n        if error == 0 or abs(error) > 40:\n            integral = 0\n        #finding derivative\n        derivative = error - prev_error\n        #setting previous error to current error\n        prev_error = error\n        #calculating speed\n        speed = Kp*error + Ki*integral + Kd*derivative\n        #setting speed\n        left_motor.set_velocity(speed)\n        right_motor.set_velocity(speed)\n        \n        #checking if turn is complete\n        if abs(error) < tol:\n            left_motor.stop()\n            right_motor.stop()\n            break\n        #allowing motors to run\n        wait(10,MSEC)\n\n   \n    #t4.set_color(Color.GREEN)\n\n# 6m forward\ndef sforward(time):\n    rightsoildnoid.retract(CYLINDER1)\n    left_motor.set_stopping(COAST)\n    right_motor.set_stopping(COAST)\n    ptoleft_motor.set_stopping(COAST)\n    ptoright_motor.set_stopping(COAST)\n    left_motor.set_velocity(100,PERCENT)\n    right_motor.set_velocity(100,PERCENT)\n    ptoleft_motor.set_velocity(100,PERCENT)\n    ptoright_motor.set_velocity(100,PERCENT)\n    ptoleft_motor.spin(REVERSE)\n    ptoright_motor.spin(FORWARD)\n    left_motor.spin(REVERSE)\n    right_motor.spin(FORWARD)\n    wait(time,MSEC)\n    left_motor.stop()\n    right_motor.stop()\n    ptoleft_motor.stop()\n    ptoright_motor.stop()\n    wait(100,MSEC)\n    rightsoildnoid.extend(CYLINDER1)\n\n\n# 6m backwards\ndef sbackward(time):\n    rightsoildnoid.retract(CYLINDER1)\n    left_motor.set_stopping(COAST)\n    right_motor.set_stopping(COAST)\n    ptoleft_motor.set_stopping(COAST)\n    ptoright_motor.set_stopping(COAST)\n    left_motor.set_velocity(100,PERCENT)\n    right_motor.set_velocity(100,PERCENT)\n    ptoleft_motor.set_velocity(100,PERCENT)\n    ptoright_motor.set_velocity(100,PERCENT)\n    ptoleft_motor.spin(FORWARD)\n    ptoright_motor.spin(REVERSE)\n    left_motor.spin(FORWARD)\n    right_motor.spin(REVERSE)\n    wait(time,MSEC)\n    left_motor.stop()\n    right_motor.stop()\n    ptoleft_motor.stop()\n    ptoright_motor.stop()\n    wait(100,MSEC)\n    rightsoildnoid.extend(CYLINDER1)\n\n\n# forward\ndef forward(time,vel):\n    left_motor.set_stopping(COAST)\n    right_motor.set_stopping(COAST)\n    left_motor.set_velocity(vel,PERCENT)\n    right_motor.set_velocity(vel,PERCENT)\n    left_motor.spin(REVERSE)\n    right_motor.spin(FORWARD)\n    wait(time,MSEC)\n    left_motor.stop()\n    right_motor.stop()\n\n# backward\ndef backward(time,vel):\n    left_motor.set_stopping(HOLD)\n    right_motor.set_stopping(HOLD)\n    left_motor.set_velocity(vel,PERCENT)\n    right_motor.set_velocity(vel,PERCENT)\n    left_motor.spin(FORWARD)\n    right_motor.spin(REVERSE)\n    wait(time,MSEC)\n    left_motor.stop()\n    right_motor.stop()\n\n# forward intake, up elevator\ndef forward_up():\n    ptoleft_motor.spin(REVERSE)\n    ptoright_motor.spin(FORWARD)\n\n# reverse intake, down elevator\ndef reverse_down():\n    ptoleft_motor.spin(FORWARD)\n    ptoright_motor.spin(REVERSE)\n\n# stop spin\ndef stopspin():\n    ptoleft_motor.stop()\n    ptoright_motor.stop()\n\n# runs auton\ndef run():\n   \n    gyro7.set_heading(0, DEGREES)\n    \n    # 4 greens\n    forward_up()\n    forward(1600,95)\n    wait(200,MSEC)\n\n    # middle\n    turning(60)\n    wait(200,MSEC)\n    forward(1400,95)\n    wait(200,MSEC)\n    turning(95)\n    wait(200,MSEC)\n    forward(2000,95)\n    wait(200,MSEC)\n\n    # 4 greens\n    turning(180)\n    wait(200,MSEC)\n    forward(1550,95)\n    wait(200,MSEC)\n\n    # star\n    turning(45)\n    wait(200,MSEC)\n    forward(2000,85)\n    wait(200,MSEC)\n    turning(345,3)\n    wait(200,MSEC)\n\n    # score in goal 2\n    leftsoildnoid.pump_on()\n    backward(1750,100)\n    stopspin()\n    leftsoildnoid.retract(CYLINDER2)\n    forward_up()\n    wait(2.75,SECONDS)\n    reverse_down()\n    leftsoildnoid.extend(CYLINDER2)\n    wait(200,MSEC)\n    forward_up()\n\n    # curve into back alley\n    left_motor.set_velocity(100,PERCENT)\n    right_motor.set_velocity(50,PERCENT)\n    left_motor.spin(REVERSE)\n    right_motor.spin(FORWARD)\n    wait(1000,MSEC)\n    left_motor.stop()\n    right_motor.stop()\n    #curve(-10,0.8,3,0,0)\n    forward(1600,95)\n    wait(200,MSEC)\n    turning(320)\n    forward(2000,85)\n    wait(750,MSEC)\n    forward(900,80)\n    wait(750,MSEC)\n    forward(1000,80)\n    wait(500,MSEC)\n    turning(265,4,2)\n    \n\n\n    # score in goal 1\n    leftsoildnoid.pump_on()\n    rightsoildnoid.pump_on()\n    backward(3400,100)\n    wait(200,MSEC)\n    leftsoildnoid.extend(CYLINDER1)\n    rightsoildnoid.extend(CYLINDER2)\n    wait(2,SECONDS)\n    forward(200,100)\n    backward(400,100)\n    wait(0.5,SECONDS)\n    leftsoildnoid.retract(CYLINDER1)\n    rightsoildnoid.retract(CYLINDER2)\n    leftsoildnoid.pump_off()\n    rightsoildnoid.pump_off()\n\n    # knock reds\n    forward_up()\n    forward(375,95)\n    leftsoildnoid.retract(CYLINDER1)\n    rightsoildnoid.retract(CYLINDER2)\n    leftsoildnoid.pump_off()\n    rightsoildnoid.pump_off()\n    curve(230,0.19,3.5,0,0,2)\n    forward(1000,95)\n    wait(200,MSEC)\n    backward(400,95)\n    wait(200,MSEC)\n    turning(180)\n    wait(200,MSEC)\n    forward(1600,95)\n    wait(200,MSEC)\n    stopspin()\n    forward(500,80)\n    wait(200,MSEC)\n    backward(500,100)\n    wait(200,MSEC)\n\n    #collect last star\n    turning(270)\n    forward_up()\n    wait(200,MSEC)\n    forward(2000,95)\n    turning(270)\n    wait(200,MSEC)\n    forward(1500,95) \n\n    #score in goal three\n    leftsoildnoid.pump_on()\n    turning(20)\n    backward(1750,100)\n    stopspin()\n    leftsoildnoid.retract(CYLINDER2)\n    forward_up()\n    wait(2.75,SECONDS)\n    reverse_down()\n    leftsoildnoid.extend(CYLINDER2)\n    wait(200,MSEC)\n    stopspin()\n    forward(1500,100)\n\n    \n\n\n    \n\n\n\n\n\n\n\n\n    \n\n\n# before auton run\nleftsoildnoid.pump_on()\nrightsoildnoid.pump_on()\ngyro7.calibrate(GyroCalibrationType.NORMAL)\ngyro7.set_heading(0,DEGREES)\nleft_motor.set_stopping(HOLD)\nright_motor.set_stopping(HOLD)\nptoright_motor.set_velocity(100,PERCENT)\nptoleft_motor.set_velocity(100,PERCENT)\nptoleft_motor.set_max_torque(100,PERCENT)\nptoright_motor.set_max_torque(100,PERCENT)\nleftsoildnoid.extend(CYLINDER2)\nleftsoildnoid.retract(CYLINDER1)\nrightsoildnoid.extend(CYLINDER1)\nrightsoildnoid.retract(CYLINDER2)\nwait(4,SECONDS)\nleftsoildnoid.pump_off()\nrightsoildnoid.pump_off()\ncontroller.buttonEUp.pressed(run)\n\n#t4.pressed(run)\n\n\n\n\n\n\n\n'''\ndef turning(target_angle, KP=-1 , KD = 0, KI = 0, tol = 1.5, p = 3, wasting_time = True):\n    left_motor.spin(REVERSE)\n    right_motor.spin(REVERSE)\n    t3.set_color(Color.RED)\n    t4.set_color(Color.RED)\n\n    # Set the constants for the PID loop\n\n\n    error_sum = 0  # Initialize the error sum\n    last_error = 0  # Initialize the last error\n    error_offset = 0\n    prev_errors = [0,0,0]\n    while True:\n        \n        left_motor.set_stopping(HOLD)\n        right_motor.set_stopping(HOLD)\n        # Read the gyro5 angle\n        facing = gyro5.heading()\n\n        # Calculate the error`\n        error = target_angle - facing\n        error = error*-1\n        if error > 180:\n            error = error-360\n        if error < -180:\n            error = error+360\n\n        ##print(str(error))\n        # Calculate the proportional term\n        p_term = KP * error\n\n        # Calculate the integral term\n        error_sum += error\n        i_term = KI * error_sum\n        #if i_term > 50 or i_term < -50: \n        #    i_term = 0\n        # Calculate the derivative term\n        d_term = KD * (error - last_error)\n        last_error = error\n\n        # Calculate the PID output\n        if i_term >= 20:\n            i_term = 0\n        pid_output = p_term + i_term/10 + d_term\n        #brain.screen.#print(str(gyro5.heading()))\n\n        \n        \n        #print(str(pid_output) + \" p:\" + str(p_term) + \" i:\" + str(i_term/10) + \" d:\" +str(d_term) + \" e:\" + str(error))\n        #print()\n        pid_output = pid_output/p\n        # Set the motor speeds based on the PID output\n        left_motor.set_velocity(pid_output)\n        right_motor.set_velocity(pid_output)\n\n        # Check if the turn is complete\n        \n        #print(str(abs(error)))\n    \n        prev_errors[error_offset] = error\n        error_offset += 1\n        if error_offset == 3:\n            error_offset = 0\n        total_errors = 0\n        change_in_error = 0\n        change_in_error_large = False\n\n        for loop in range(len(prev_errors)):\n            ##print(str(i))\n            prev_error_number = prev_errors[loop]\n            total_errors += prev_error_number\n            if loop > 0:\n                change_in_error = prev_errors[loop] - prev_errors[loop-1]\n                #print(change_in_error)\n                if abs(float(change_in_error)) >= 0.07:\n                    change_in_error_large = True\n        if prev_errors[2] != 0:\n            if not change_in_error_large:\n                for x in range(5):\n                    pass\n                KP += 0.05\n        avg_error = total_errors/len(prev_errors)\n        if abs(error) < tol and abs(avg_error) < tol:\n            left_motor.stop()\n            right_motor.stop()\n            break\n\n        wait(10,MSEC)  # Wait for 20ms to allow the motors to move\n\n\n\n\n    t3.set_color(Color.GREEN)\n    t4.set_color(Color.GREEN)\n'''\n'''\n    # middle\n    turning(60)\n    wait(200,MSEC)\n    forward(1400,90)\n    wait(200,MSEC)\n    turning(105)\n    wait(200,MSEC)\n    forward(1350,95)\n    wait(200,MSEC)\n    \n    # 4 greens\n    turning(180)\n    wait(200,MSEC)\n    forward(1100,95)\n    wait(200,MSEC)\n\n    # star\n    turning(50)\n    wait(200,MSEC)\n    forward(2300,80)\n    wait(200,MSEC)\n    turning(350,5)\n    solenoid.pump_on()\n    wait(200,MSEC)\n\n    # score in goal 2\n    backward(1650,100)\n    solenoid.extend(CYLINDER2)\n    reverse_up()\n    wait(2.7,SECONDS)\n    stopspin()\n    wait(500,MSEC)\n    solenoid.retract(CYLINDER2)\n    solenoid.pump_off()\n    forward_down()\n    \n    # curve, 2 stars\n    forward_down()\n    curve(350,0.7,3,0,0)\n    forward(1450,95)\n    wait(200,MSEC)\n    turning(318)\n    wait(200,MSEC)\n    forward(1800,70)\n    wait(200,MSEC)\n    turning(270,2)\n    wait(800,MSEC)\n    forward(600,95)\n    wait(800,MSEC)\n    forward(1100,70)\n    wait(800,MSEC)\n    turning(268,2,1.3)\n    wait(200,MSEC)\n\n    # score in goal 1\n    solenoid.pump_on()\n    backward(3200,100)\n    solenoid.extend(CYLINDER1)\n    wait(1.7,SECONDS)\n    forward(200,100)\n    backward(400,100)\n    wait(1,SECONDS)\n    \n    # knock reds\n    forward(250,95)\n    solenoid.retract(CYLINDER1)\n    solenoid.pump_off()\n    curve(230,0.15,3.5,0,0,2)\n    forward(1000,95)\n    wait(200,MSEC)\n    backward(200,95)\n    wait(200,MSEC)\n    turning(185)\n    wait(200,MSEC)\n    forward(1300,95)\n    stopspin()\n    forward(300,95)\n    wait(200,MSEC)\n    backward(500,95)\n    wait(200,MSEC)\n\n    # star\n    turning(268,1.5,0.9)\n    forward_down()\n    wait(200,MSEC)\n    forward(1400,95)\n    wait(500,MSEC)\n    forward(1000,70)\n    wait(600,MSEC)\n    turning(15)\n    solenoid.pump_on()\n    wait(200,MSEC)\n\n    # dump in goal 3\n    backward(1200,100)\n    solenoid.extend(CYLINDER2)\n    reverse_up()\n    wait(2.7,SECONDS)\n    stopspin()\n    wait(500,MSEC)\n    solenoid.retract(CYLINDER2)\n    solenoid.pump_off()\n\n    # partial park\n    forward(1500,100)\n'''","textLanguage":"python","rconfig":[{"port":[6],"name":"left_motor","customName":true,"deviceType":"Motor","deviceClass":"motor","setting":{"reversed":"false","fwd":"forward","rev":"reverse"},"triportSourcePort":22},{"port":[12],"name":"right_motor","customName":true,"deviceType":"Motor","deviceClass":"motor","setting":{"reversed":"false","fwd":"forward","rev":"reverse"},"triportSourcePort":22},{"port":[4,5],"name":"ptoleft_motor","customName":true,"deviceType":"MotorGroup","deviceClass":"motor_group","setting":{"fwd":"forward","rev":"reverse","motor_a_reversed":"false","motor_b_reversed":"false"},"triportSourcePort":22},{"port":[10,11],"name":"ptoright_motor","customName":true,"deviceType":"MotorGroup","deviceClass":"motor_group","setting":{"fwd":"forward","rev":"reverse","motor_a_reversed":"false","motor_b_reversed":"false"},"triportSourcePort":22},{"port":[3],"name":"leftsoildnoid","customName":true,"deviceType":"Pneumatic","deviceClass":"pneumatic","setting":{"cylinder1":"cylinder1","cylinder2":"cylinder2","cylinder1_reversed":"false","cylinder2_reversed":"false"},"triportSourcePort":22},{"port":[9],"name":"rightsoildnoid","customName":true,"deviceType":"Pneumatic","deviceClass":"pneumatic","setting":{"cylinder1":"cylinder1","cylinder2":"cylinder2","cylinder1_reversed":"false","cylinder2_reversed":"false"},"triportSourcePort":22},{"port":[],"name":"controller","customName":false,"deviceType":"Controller","deviceClass":"controller","setting":{"left":"","leftDir":"false","right":"","rightDir":"false","e":"","eDir":"false","f":"","fDir":"false","l3r3":"","l3r3Dir":"false","drive":"none"},"triportSourcePort":22},{"port":[7],"name":"gyro7","customName":true,"deviceType":"Gyro","deviceClass":"gyro","setting":{},"triportSourcePort":22}],"slot":3,"platform":"IQ","sdkVersion":"20230818.11.00.00","appVersion":"3.0.4","minVersion":"3.0.0","fileFormat":"1.2.0","icon":"","targetBrainGen":"Second","v5SoundsEnabled":false,"target":"Physical"}